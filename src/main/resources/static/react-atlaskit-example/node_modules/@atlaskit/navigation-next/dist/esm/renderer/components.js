import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectSpread from "@babel/runtime/helpers/objectSpread";
import _extends from "@babel/runtime/helpers/extends";
import _css from "@emotion/css";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import { jsx as ___EmotionJSX } from "@emotion/core";
import React, { PureComponent } from 'react';
import Loadable from 'react-loadable';
import { gridSize as gridSizeFn } from '@atlaskit/theme/constants';
import { navigationItemClicked } from '../common/analytics';
import RenderBlocker from '../components/common/RenderBlocker';
import ContainerHeaderComponent from '../components/presentational/ContainerHeader';
import GroupComponent from '../components/presentational/Group';
import GroupHeadingComponent from '../components/presentational/GroupHeading';
import HeaderSectionComponent from '../components/presentational/HeaderSection';
import MenuSectionComponent from '../components/presentational/MenuSection';
import SectionComponent from '../components/presentational/Section';
import SectionHeadingComponent from '../components/presentational/SectionHeading';
import Separator from '../components/presentational/Separator';
import Wordmark from '../components/presentational/Wordmark';
import BackItem from '../components/connected/BackItem';
import ConnectedItem from '../components/connected/ConnectedItem';
import GoToItem from '../components/connected/GoToItem';
var gridSize = gridSizeFn();

var loadSwitcher = function loadSwitcher() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/switcher" */
  '../components/presentational/Switcher');
};

var LazySwitcher = Loadable({
  loader: loadSwitcher,
  loading: function loading() {
    return null;
  }
});

var loadSortableContextComponent = function loadSortableContextComponent() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/sortable-context-component" */
  '../components/connected/SortableContext');
};

var LazySortableContextComponent = Loadable({
  loader: loadSortableContextComponent,
  loading: function loading() {
    return null;
  }
});

var loadSortableGroupComponent = function loadSortableGroupComponent() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/sortable-group-component" */
  '../components/connected/SortableGroup');
};

export var LazySortableGroupComponent = Loadable({
  loader: loadSortableGroupComponent,
  loading: function loading() {
    return null;
  }
});

var loadSortableItem = function loadSortableItem() {
  return import(
  /* webpackChunkName: "@atlaskit/navigation-next/async-chunk/sortable-item" */
  '../components/connected/SortableItem');
};

export var LazySortableItem = Loadable({
  loader: loadSortableItem,
  loading: function loading() {
    return null;
  }
});
/**
 * ITEMS
 */
// Title

var GroupHeading = function GroupHeading(_ref) {
  var text = _ref.text,
      props = _objectWithoutProperties(_ref, ["text"]);

  return ___EmotionJSX(GroupHeadingComponent, props, text);
}; // SectionHeading


var SectionHeading = function SectionHeading(_ref2) {
  var text = _ref2.text,
      props = _objectWithoutProperties(_ref2, ["text"]);

  return ___EmotionJSX(SectionHeadingComponent, props, text);
}; // ContainerHeader


var ContainerHeader = function ContainerHeader(props) {
  return (// -2px here to account for the extra space at the top of a MenuSection for
    // the scroll hint.
    ___EmotionJSX("div", {
      css:
      /*#__PURE__*/
      _css({
        paddingBottom: gridSize * 2.5 - 2
      }, process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTRFTyIsImZpbGUiOiIuLi8uLi8uLi9zcmMvcmVuZGVyZXIvY29tcG9uZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IExvYWRhYmxlIGZyb20gJ3JlYWN0LWxvYWRhYmxlJztcbmltcG9ydCB7IGdyaWRTaXplIGFzIGdyaWRTaXplRm4gfSBmcm9tICdAYXRsYXNraXQvdGhlbWUvY29uc3RhbnRzJztcblxuaW1wb3J0IHsgbmF2aWdhdGlvbkl0ZW1DbGlja2VkIH0gZnJvbSAnLi4vY29tbW9uL2FuYWx5dGljcyc7XG5cbmltcG9ydCBSZW5kZXJCbG9ja2VyIGZyb20gJy4uL2NvbXBvbmVudHMvY29tbW9uL1JlbmRlckJsb2NrZXInO1xuXG5pbXBvcnQgQ29udGFpbmVySGVhZGVyQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvQ29udGFpbmVySGVhZGVyJztcbmltcG9ydCBHcm91cENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL0dyb3VwJztcbmltcG9ydCBHcm91cEhlYWRpbmdDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9Hcm91cEhlYWRpbmcnO1xuaW1wb3J0IEhlYWRlclNlY3Rpb25Db21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9IZWFkZXJTZWN0aW9uJztcbmltcG9ydCBNZW51U2VjdGlvbkNvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL01lbnVTZWN0aW9uJztcbmltcG9ydCBTZWN0aW9uQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU2VjdGlvbic7XG5pbXBvcnQgU2VjdGlvbkhlYWRpbmdDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9TZWN0aW9uSGVhZGluZyc7XG5pbXBvcnQgU2VwYXJhdG9yIGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU2VwYXJhdG9yJztcbmltcG9ydCBXb3JkbWFyayBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL1dvcmRtYXJrJztcblxuaW1wb3J0IEJhY2tJdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL0JhY2tJdGVtJztcbmltcG9ydCBDb25uZWN0ZWRJdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL0Nvbm5lY3RlZEl0ZW0nO1xuaW1wb3J0IEdvVG9JdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL0dvVG9JdGVtJztcblxuY29uc3QgZ3JpZFNpemUgPSBncmlkU2l6ZUZuKCk7XG5jb25zdCBsb2FkU3dpdGNoZXIgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3N3aXRjaGVyXCIgKi8gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU3dpdGNoZXInXG4gICk7XG5jb25zdCBMYXp5U3dpdGNoZXIgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFN3aXRjaGVyLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG5cbmNvbnN0IGxvYWRTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3NvcnRhYmxlLWNvbnRleHQtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlQ29udGV4dCdcbiAgKTtcbmNvbnN0IExhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlQ29udGV4dENvbXBvbmVudCxcbiAgbG9hZGluZzogKCkgPT4gbnVsbCxcbn0pO1xuXG5jb25zdCBsb2FkU29ydGFibGVHcm91cENvbXBvbmVudCA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtZ3JvdXAtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlR3JvdXAnXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlR3JvdXBDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlR3JvdXBDb21wb25lbnQsXG4gIGxvYWRpbmc6ICgpID0+IG51bGwsXG59KTtcblxuY29uc3QgbG9hZFNvcnRhYmxlSXRlbSA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtaXRlbVwiICovICcuLi9jb21wb25lbnRzL2Nvbm5lY3RlZC9Tb3J0YWJsZUl0ZW0nXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlSXRlbSA9IExvYWRhYmxlKHtcbiAgbG9hZGVyOiBsb2FkU29ydGFibGVJdGVtLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG4vKipcbiAqIElURU1TXG4gKi9cblxuLy8gVGl0bGVcbmNvbnN0IEdyb3VwSGVhZGluZyA9ICh7IHRleHQsIC4uLnByb3BzIH0pID0+IChcbiAgPEdyb3VwSGVhZGluZ0NvbXBvbmVudCB7Li4ucHJvcHN9Pnt0ZXh0fTwvR3JvdXBIZWFkaW5nQ29tcG9uZW50PlxuKTtcblxuLy8gU2VjdGlvbkhlYWRpbmdcbmNvbnN0IFNlY3Rpb25IZWFkaW5nID0gKHsgdGV4dCwgLi4ucHJvcHMgfSkgPT4gKFxuICA8U2VjdGlvbkhlYWRpbmdDb21wb25lbnQgey4uLnByb3BzfT57dGV4dH08L1NlY3Rpb25IZWFkaW5nQ29tcG9uZW50PlxuKTtcblxuLy8gQ29udGFpbmVySGVhZGVyXG5jb25zdCBDb250YWluZXJIZWFkZXIgPSBwcm9wcyA9PiAoXG4gIC8vIC0ycHggaGVyZSB0byBhY2NvdW50IGZvciB0aGUgZXh0cmEgc3BhY2UgYXQgdGhlIHRvcCBvZiBhIE1lbnVTZWN0aW9uIGZvclxuICAvLyB0aGUgc2Nyb2xsIGhpbnQuXG4gIDxkaXYgY3NzPXt7IHBhZGRpbmdCb3R0b206IGdyaWRTaXplICogMi41IC0gMiB9fT5cbiAgICA8Q29udGFpbmVySGVhZGVyQ29tcG9uZW50IHsuLi5wcm9wc30gLz5cbiAgPC9kaXY+XG4pO1xuXG5jb25zdCBEZWJ1ZyA9IHByb3BzID0+IChcbiAgPHByZVxuICAgIGNzcz17e1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcbiAgICAgIGZvbnRTaXplOiAnMTBweCcsXG4gICAgICBvdmVyZmxvd1g6ICdhdXRvJyxcbiAgICAgIHBhZGRpbmc6IGAke2dyaWRTaXplIC8gMn1weGAsXG4gICAgfX1cbiAgPlxuICAgIHtKU09OLnN0cmluZ2lmeShwcm9wcywgbnVsbCwgMil9XG4gIDwvcHJlPlxuKTtcblxuLyoqXG4gKiBHUk9VUFNcbiAqL1xuXG4vLyBHcm91cFxuY29uc3QgR3JvdXAgPSAoeyBjdXN0b21Db21wb25lbnRzLCBoYXNTZXBhcmF0b3IsIGhlYWRpbmcsIGl0ZW1zLCBpZCB9KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPEdyb3VwQ29tcG9uZW50IGhlYWRpbmc9e2hlYWRpbmd9IGhhc1NlcGFyYXRvcj17aGFzU2VwYXJhdG9yfSBpZD17aWR9PlxuICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgPC9Hcm91cENvbXBvbmVudD5cbiAgKSA6IG51bGw7XG5cbmNvbnN0IFNvcnRhYmxlR3JvdXAgPSAoe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBoYXNTZXBhcmF0b3IsXG4gIGhlYWRpbmcsXG4gIGl0ZW1zLFxuICBpZCxcbn0pID0+XG4gIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA/IChcbiAgICA8TGF6eVNvcnRhYmxlR3JvdXBDb21wb25lbnRcbiAgICAgIGhlYWRpbmc9e2hlYWRpbmd9XG4gICAgICBoYXNTZXBhcmF0b3I9e2hhc1NlcGFyYXRvcn1cbiAgICAgIGlkPXtpZH1cbiAgICA+XG4gICAgICA8UmVuZGVyQmxvY2tlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9PlxuICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyIGl0ZW1zPXtpdGVtc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICAgIDwvUmVuZGVyQmxvY2tlcj5cbiAgICA8L0xhenlTb3J0YWJsZUdyb3VwQ29tcG9uZW50PlxuICApIDogbnVsbDtcblxuLy8gU2VjdGlvblxuY29uc3QgU2VjdGlvbiA9ICh7XG4gIGFsd2F5c1Nob3dTY3JvbGxIaW50ID0gZmFsc2UsXG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGlkLFxuICBpdGVtcyxcbiAgbmVzdGVkR3JvdXBLZXksXG4gIHBhcmVudElkLFxuICBzaG91bGRHcm93LFxufSkgPT5cbiAgaXRlbXMubGVuZ3RoID8gKFxuICAgIDxTZWN0aW9uQ29tcG9uZW50XG4gICAgICBhbHdheXNTaG93U2Nyb2xsSGludD17YWx3YXlzU2hvd1Njcm9sbEhpbnR9XG4gICAgICBpZD17aWR9XG4gICAgICBrZXk9e25lc3RlZEdyb3VwS2V5fVxuICAgICAgcGFyZW50SWQ9e3BhcmVudElkfVxuICAgICAgc2hvdWxkR3Jvdz17c2hvdWxkR3Jvd31cbiAgICA+XG4gICAgICB7KHsgY2xhc3NOYW1lIH0pID0+IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlclxuICAgICAgICAgICAgaXRlbXM9e2l0ZW1zfVxuICAgICAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9TZWN0aW9uQ29tcG9uZW50PlxuICApIDogbnVsbDtcblxuY29uc3QgSGVhZGVyU2VjdGlvbiA9ICh7IGN1c3RvbUNvbXBvbmVudHMsIGlkLCBpdGVtcywgbmVzdGVkR3JvdXBLZXkgfSkgPT5cbiAgaXRlbXMubGVuZ3RoID8gKFxuICAgIDxIZWFkZXJTZWN0aW9uQ29tcG9uZW50IGlkPXtpZH0ga2V5PXtuZXN0ZWRHcm91cEtleX0+XG4gICAgICB7KHsgY2xhc3NOYW1lIH0pID0+IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlclxuICAgICAgICAgICAgaXRlbXM9e2l0ZW1zfVxuICAgICAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9IZWFkZXJTZWN0aW9uQ29tcG9uZW50PlxuICApIDogbnVsbDtcblxuY29uc3QgTWVudVNlY3Rpb24gPSAoe1xuICBhbHdheXNTaG93U2Nyb2xsSGludCxcbiAgY3VzdG9tQ29tcG9uZW50cyxcbiAgaWQsXG4gIGl0ZW1zLFxuICBuZXN0ZWRHcm91cEtleSxcbiAgcGFyZW50SWQsXG59KSA9PiAoXG4gIDxNZW51U2VjdGlvbkNvbXBvbmVudFxuICAgIGFsd2F5c1Nob3dTY3JvbGxIaW50PXthbHdheXNTaG93U2Nyb2xsSGludH1cbiAgICBpZD17aWR9XG4gICAga2V5PXtuZXN0ZWRHcm91cEtleX1cbiAgICBwYXJlbnRJZD17cGFyZW50SWR9XG4gID5cbiAgICB7KHsgY2xhc3NOYW1lIH0pID0+IChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyIGl0ZW1zPXtpdGVtc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICAgIDwvZGl2PlxuICAgICl9XG4gIDwvTWVudVNlY3Rpb25Db21wb25lbnQ+XG4pO1xuXG5jb25zdCBTb3J0YWJsZUNvbnRleHQgPSAoe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBpZCxcbiAgaXRlbXMsXG4gIG9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdVcGRhdGUsXG4gIG9uRHJhZ0VuZCxcbn0pID0+XG4gIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA/IChcbiAgICA8TGF6eVNvcnRhYmxlQ29udGV4dENvbXBvbmVudFxuICAgICAgaWQ9e2lkfVxuICAgICAgb25EcmFnU3RhcnQ9e29uRHJhZ1N0YXJ0fVxuICAgICAgb25EcmFnVXBkYXRlPXtvbkRyYWdVcGRhdGV9XG4gICAgICBvbkRyYWdFbmQ9e29uRHJhZ0VuZH1cbiAgICA+XG4gICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyIGl0ZW1zPXtpdGVtc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICA8L0xhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnQ+XG4gICkgOiBudWxsO1xuXG5jb25zdCBpdGVtQ29tcG9uZW50cyA9IHtcbiAgQmFja0l0ZW0sXG4gIENvbnRhaW5lckhlYWRlcixcbiAgRGVidWcsXG4gIEdvVG9JdGVtLFxuICBHcm91cEhlYWRpbmcsXG4gIEl0ZW06IENvbm5lY3RlZEl0ZW0sXG4gIFNvcnRhYmxlSXRlbTogTGF6eVNvcnRhYmxlSXRlbSxcbiAgU2VjdGlvbkhlYWRpbmcsXG4gIFNlcGFyYXRvcixcbiAgU3dpdGNoZXI6IExhenlTd2l0Y2hlcixcbiAgV29yZG1hcmssXG59O1xuXG5jb25zdCByZW5kZXJJdGVtQ29tcG9uZW50ID0gKHByb3BzLCBrZXksIGluZGV4KSA9PiB7XG4gIGxldCBlbGVtZW50ID0gbnVsbDtcbiAgLy8gV2UgbmVlZCBhbiBleHBsaWNpdCBjb25kaXRpb25hbCBhZ2FpbnN0IGVhY2ggdHlwZSBmb3IgZmxvdyB0eXBlIHJlZmluZW1lbnQgdG8gd29ya1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ0JhY2tJdGVtJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPEJhY2tJdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdDb250YWluZXJIZWFkZXInKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8Q29udGFpbmVySGVhZGVyIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnRGVidWcnKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8RGVidWcga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdHb1RvSXRlbScpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxHb1RvSXRlbSBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gaW5kZXg9e2luZGV4fSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnSXRlbScpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxDb25uZWN0ZWRJdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTb3J0YWJsZUl0ZW0nKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8TGF6eVNvcnRhYmxlSXRlbSBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gaW5kZXg9e2luZGV4fSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU2VjdGlvbkhlYWRpbmcnKSB7XG4gICAgY29uc3QgeyB0eXBlLCBpZCwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPFNlY3Rpb25IZWFkaW5nIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU2VwYXJhdG9yJykge1xuICAgIGNvbnN0IHsgdHlwZSwgaWQsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxTZXBhcmF0b3Iga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTd2l0Y2hlcicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxMYXp5U3dpdGNoZXIga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdXb3JkbWFyaycpIHtcbiAgICBjb25zdCB7IHR5cGUsIGlkLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8V29yZG1hcmsga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5jb25zdCBncm91cENvbXBvbmVudHMgPSB7XG4gIEdyb3VwLFxuICBIZWFkZXJTZWN0aW9uLFxuICBNZW51U2VjdGlvbixcbiAgU2VjdGlvbixcbiAgU29ydGFibGVDb250ZXh0LFxuICBTb3J0YWJsZUdyb3VwLFxufTtcblxuY29uc3QgcmVuZGVyR3JvdXBDb21wb25lbnQgPSAocHJvcHMsIGtleSwgY3VzdG9tQ29tcG9uZW50cykgPT4ge1xuICBsZXQgZWxlbWVudCA9IG51bGw7XG4gIC8vIFdlIG5lZWQgYW4gZXhwbGljaXQgY29uZGl0aW9uYWwgYWdhaW5zdCBlYWNoIHR5cGUgZm9yIGZsb3cgdHlwZSByZWZpbmVtZW50IHRvIHdvcmtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdHcm91cCcpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxHcm91cCBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICApO1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdIZWFkZXJTZWN0aW9uJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPEhlYWRlclNlY3Rpb25cbiAgICAgICAga2V5PXtrZXl9XG4gICAgICAgIHsuLi5jb21wUHJvcHN9XG4gICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAvPlxuICAgICk7XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ01lbnVTZWN0aW9uJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPE1lbnVTZWN0aW9uXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB7Li4uY29tcFByb3BzfVxuICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgLz5cbiAgICApO1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTZWN0aW9uJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPFNlY3Rpb24ga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU29ydGFibGVDb250ZXh0Jykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPFNvcnRhYmxlQ29udGV4dFxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgey4uLmNvbXBQcm9wc31cbiAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgIC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU29ydGFibGVHcm91cCcpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxTb3J0YWJsZUdyb3VwXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB7Li4uY29tcFByb3BzfVxuICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vLyBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuZXhwb3J0IGNvbnN0IGNvbXBvbmVudHMgPSB7IC4uLml0ZW1Db21wb25lbnRzLCAuLi5ncm91cENvbXBvbmVudHMgfTtcblxuLyoqXG4gKiBSRU5ERVJFUlxuICovXG5jbGFzcyBUeXBlZEl0ZW1zUmVuZGVyZXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY3VzdG9tQ29tcG9uZW50c1dpdGhBbmFseXRpY3MgPSBuZXcgTWFwKCk7XG5cbiAgZ2V0Q3VzdG9tQ29tcG9uZW50ID0gY29tcG9uZW50ID0+IHtcbiAgICAvLyBjYWNoZSBjdXN0b20gY29tcG9uZW50cyB3cmFwcGVkIHdpdGggYW5hbHl0aWNzXG4gICAgLy8gdG8gcHJldmVudCByZS1tb3VudGluZyBvZiBjb21wb25lbnQgb24gcmUtcmVuZGVyXG4gICAgY29uc3QgeyBjdXN0b21Db21wb25lbnRzID0ge30gfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IGNhY2hlZENvbXBvbmVudCA9IHRoaXMuY3VzdG9tQ29tcG9uZW50c1dpdGhBbmFseXRpY3MuZ2V0KGNvbXBvbmVudCk7XG4gICAgaWYgKCFjYWNoZWRDb21wb25lbnQpIHtcbiAgICAgIGNhY2hlZENvbXBvbmVudCA9XG4gICAgICAgIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgPyBuYXZpZ2F0aW9uSXRlbUNsaWNrZWQoY3VzdG9tQ29tcG9uZW50c1tjb21wb25lbnRdLCBjb21wb25lbnQpXG4gICAgICAgICAgOiBuYXZpZ2F0aW9uSXRlbUNsaWNrZWQoXG4gICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgY29tcG9uZW50LmRpc3BsYXlOYW1lIHx8ICdpbmxpbmVDdXN0b21Db21wb25lbnQnLFxuICAgICAgICAgICAgKTtcbiAgICAgIHRoaXMuY3VzdG9tQ29tcG9uZW50c1dpdGhBbmFseXRpY3Muc2V0KGNvbXBvbmVudCwgY2FjaGVkQ29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZENvbXBvbmVudDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjdXN0b21Db21wb25lbnRzID0ge30sIGl0ZW1zIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gV2UgY2Fubm90IGRlc3RydWN0dXJlIHByb3BzLnR5cGUgb3RoZXJ3aXNlIGZsb3cgdHlwZSByZWZpbm1lbnQgZG9lcyBub3Qgd29ya1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81MjU5XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgocHJvcHMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBrZXkgPVxuICAgICAgICB0eXBlb2YgcHJvcHMubmVzdGVkR3JvdXBLZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgPyBwcm9wcy5uZXN0ZWRHcm91cEtleVxuICAgICAgICAgIDogcHJvcHMuaWQ7XG5cbiAgICAgIGlmIChwcm9wcy50eXBlID09PSAnSW5saW5lQ29tcG9uZW50Jykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIGNvbXBvbmVudCwgLi4uY29tcG9uZW50UHJvcHMgfSA9IHByb3BzO1xuICAgICAgICAvLyBJZiB0aGV5J3ZlIHByb3ZpZGVkIGEgY29tcG9uZW50IGFzIHRoZSB0eXBlXG4gICAgICAgIGNvbnN0IEN1c3RvbUNvbXBvbmVudCA9IHRoaXMuZ2V0Q3VzdG9tQ29tcG9uZW50KHByb3BzLmNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPEN1c3RvbUNvbXBvbmVudFxuICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICB7Li4uY29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAvLyBXZSBwYXNzIG91ciBpbi1idWlsdCBjb21wb25lbnRzIHRocm91Z2ggdG8gY3VzdG9tIGNvbXBvbmVudHMgc29cbiAgICAgICAgICAgIC8vIHRoZXkgY2FuIHdyYXAvcmVuZGVyIHRoZW0gaWYgdGhleSB3YW50IHRvLlxuICAgICAgICAgICAgY29tcG9uZW50cz17Y29tcG9uZW50c31cbiAgICAgICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhncm91cENvbXBvbmVudHMpLmluY2x1ZGVzKHByb3BzLnR5cGUpKSB7XG4gICAgICAgIC8vIElmIHRoZXkndmUgcHJvdmlkZWQgYSB0eXBlIHdoaWNoIG1hdGNoZXMgb25lIG9mIG91ciBpbi1idWlsdCBncm91cFxuICAgICAgICAvLyBjb21wb25lbnRzXG4gICAgICAgIHJldHVybiByZW5kZXJHcm91cENvbXBvbmVudChwcm9wcywga2V5LCBjdXN0b21Db21wb25lbnRzKTtcbiAgICAgICAgLy8gSWYgdGhleSd2ZSBwcm92aWRlZCBhIHR5cGUgd2hpY2ggbWF0Y2hlcyBvbmUgb2Ygb3VyIGluLWJ1aWx0IGl0ZW1cbiAgICAgICAgLy8gY29tcG9uZW50cy5cbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhpdGVtQ29tcG9uZW50cykuaW5jbHVkZXMocHJvcHMudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckl0ZW1Db21wb25lbnQocHJvcHMsIGtleSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGN1c3RvbUNvbXBvbmVudHMpLmluY2x1ZGVzKHByb3BzLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcG9uZW50UHJvcHMgfSA9IHByb3BzO1xuICAgICAgICAvLyBJZiB0aGV5J3ZlIHByb3ZpZGVkIGEgdHlwZSB3aGljaCBtYXRjaGVzIG9uZSBvZiB0aGVpciBkZWZpbmVkIGN1c3RvbVxuICAgICAgICAvLyBjb21wb25lbnRzLlxuICAgICAgICBjb25zdCBDdXN0b21Db21wb25lbnQgPSB0aGlzLmdldEN1c3RvbUNvbXBvbmVudCh0eXBlKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50XG4gICAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICAgIHsuLi5jb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIC8vIFdlIHBhc3Mgb3VyIGluLWJ1aWx0IGNvbXBvbmVudHMgdGhyb3VnaCB0byBjdXN0b20gY29tcG9uZW50cyBzb1xuICAgICAgICAgICAgLy8gdGhleSBjYW4gd3JhcC9yZW5kZXIgdGhlbSBpZiB0aGV5IHdhbnQgdG8uXG4gICAgICAgICAgICBjb21wb25lbnRzPXtjb21wb25lbnRzfVxuICAgICAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgICAgICAvPlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gPERlYnVnIGtleT17a2V5fSB0eXBlPXtwcm9wcy50eXBlfSB7Li4ucHJvcHN9IC8+O1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFR5cGVkSXRlbXNSZW5kZXJlcjtcbiJdfQ== */")
    }, ___EmotionJSX(ContainerHeaderComponent, props))
  );
};

var Debug = function Debug(props) {
  return ___EmotionJSX("pre", {
    css:
    /*#__PURE__*/
    _css({
      backgroundColor: 'rgba(0, 0, 0, 0.1)',
      fontSize: '10px',
      overflowX: 'auto',
      padding: "".concat(gridSize / 2, "px")
    }, process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1GSSIsImZpbGUiOiIuLi8uLi8uLi9zcmMvcmVuZGVyZXIvY29tcG9uZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IExvYWRhYmxlIGZyb20gJ3JlYWN0LWxvYWRhYmxlJztcbmltcG9ydCB7IGdyaWRTaXplIGFzIGdyaWRTaXplRm4gfSBmcm9tICdAYXRsYXNraXQvdGhlbWUvY29uc3RhbnRzJztcblxuaW1wb3J0IHsgbmF2aWdhdGlvbkl0ZW1DbGlja2VkIH0gZnJvbSAnLi4vY29tbW9uL2FuYWx5dGljcyc7XG5cbmltcG9ydCBSZW5kZXJCbG9ja2VyIGZyb20gJy4uL2NvbXBvbmVudHMvY29tbW9uL1JlbmRlckJsb2NrZXInO1xuXG5pbXBvcnQgQ29udGFpbmVySGVhZGVyQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvQ29udGFpbmVySGVhZGVyJztcbmltcG9ydCBHcm91cENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL0dyb3VwJztcbmltcG9ydCBHcm91cEhlYWRpbmdDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9Hcm91cEhlYWRpbmcnO1xuaW1wb3J0IEhlYWRlclNlY3Rpb25Db21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9IZWFkZXJTZWN0aW9uJztcbmltcG9ydCBNZW51U2VjdGlvbkNvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL01lbnVTZWN0aW9uJztcbmltcG9ydCBTZWN0aW9uQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU2VjdGlvbic7XG5pbXBvcnQgU2VjdGlvbkhlYWRpbmdDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9wcmVzZW50YXRpb25hbC9TZWN0aW9uSGVhZGluZyc7XG5pbXBvcnQgU2VwYXJhdG9yIGZyb20gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU2VwYXJhdG9yJztcbmltcG9ydCBXb3JkbWFyayBmcm9tICcuLi9jb21wb25lbnRzL3ByZXNlbnRhdGlvbmFsL1dvcmRtYXJrJztcblxuaW1wb3J0IEJhY2tJdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL0JhY2tJdGVtJztcbmltcG9ydCBDb25uZWN0ZWRJdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL0Nvbm5lY3RlZEl0ZW0nO1xuaW1wb3J0IEdvVG9JdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL0dvVG9JdGVtJztcblxuY29uc3QgZ3JpZFNpemUgPSBncmlkU2l6ZUZuKCk7XG5jb25zdCBsb2FkU3dpdGNoZXIgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3N3aXRjaGVyXCIgKi8gJy4uL2NvbXBvbmVudHMvcHJlc2VudGF0aW9uYWwvU3dpdGNoZXInXG4gICk7XG5jb25zdCBMYXp5U3dpdGNoZXIgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFN3aXRjaGVyLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG5cbmNvbnN0IGxvYWRTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSAoKSA9PlxuICBpbXBvcnQoXG4gICAgLyogd2VicGFja0NodW5rTmFtZTogXCJAYXRsYXNraXQvbmF2aWdhdGlvbi1uZXh0L2FzeW5jLWNodW5rL3NvcnRhYmxlLWNvbnRleHQtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlQ29udGV4dCdcbiAgKTtcbmNvbnN0IExhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlQ29udGV4dENvbXBvbmVudCxcbiAgbG9hZGluZzogKCkgPT4gbnVsbCxcbn0pO1xuXG5jb25zdCBsb2FkU29ydGFibGVHcm91cENvbXBvbmVudCA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtZ3JvdXAtY29tcG9uZW50XCIgKi8gJy4uL2NvbXBvbmVudHMvY29ubmVjdGVkL1NvcnRhYmxlR3JvdXAnXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlR3JvdXBDb21wb25lbnQgPSBMb2FkYWJsZSh7XG4gIGxvYWRlcjogbG9hZFNvcnRhYmxlR3JvdXBDb21wb25lbnQsXG4gIGxvYWRpbmc6ICgpID0+IG51bGwsXG59KTtcblxuY29uc3QgbG9hZFNvcnRhYmxlSXRlbSA9ICgpID0+XG4gIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkBhdGxhc2tpdC9uYXZpZ2F0aW9uLW5leHQvYXN5bmMtY2h1bmsvc29ydGFibGUtaXRlbVwiICovICcuLi9jb21wb25lbnRzL2Nvbm5lY3RlZC9Tb3J0YWJsZUl0ZW0nXG4gICk7XG5leHBvcnQgY29uc3QgTGF6eVNvcnRhYmxlSXRlbSA9IExvYWRhYmxlKHtcbiAgbG9hZGVyOiBsb2FkU29ydGFibGVJdGVtLFxuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxufSk7XG4vKipcbiAqIElURU1TXG4gKi9cblxuLy8gVGl0bGVcbmNvbnN0IEdyb3VwSGVhZGluZyA9ICh7IHRleHQsIC4uLnByb3BzIH0pID0+IChcbiAgPEdyb3VwSGVhZGluZ0NvbXBvbmVudCB7Li4ucHJvcHN9Pnt0ZXh0fTwvR3JvdXBIZWFkaW5nQ29tcG9uZW50PlxuKTtcblxuLy8gU2VjdGlvbkhlYWRpbmdcbmNvbnN0IFNlY3Rpb25IZWFkaW5nID0gKHsgdGV4dCwgLi4ucHJvcHMgfSkgPT4gKFxuICA8U2VjdGlvbkhlYWRpbmdDb21wb25lbnQgey4uLnByb3BzfT57dGV4dH08L1NlY3Rpb25IZWFkaW5nQ29tcG9uZW50PlxuKTtcblxuLy8gQ29udGFpbmVySGVhZGVyXG5jb25zdCBDb250YWluZXJIZWFkZXIgPSBwcm9wcyA9PiAoXG4gIC8vIC0ycHggaGVyZSB0byBhY2NvdW50IGZvciB0aGUgZXh0cmEgc3BhY2UgYXQgdGhlIHRvcCBvZiBhIE1lbnVTZWN0aW9uIGZvclxuICAvLyB0aGUgc2Nyb2xsIGhpbnQuXG4gIDxkaXYgY3NzPXt7IHBhZGRpbmdCb3R0b206IGdyaWRTaXplICogMi41IC0gMiB9fT5cbiAgICA8Q29udGFpbmVySGVhZGVyQ29tcG9uZW50IHsuLi5wcm9wc30gLz5cbiAgPC9kaXY+XG4pO1xuXG5jb25zdCBEZWJ1ZyA9IHByb3BzID0+IChcbiAgPHByZVxuICAgIGNzcz17e1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcbiAgICAgIGZvbnRTaXplOiAnMTBweCcsXG4gICAgICBvdmVyZmxvd1g6ICdhdXRvJyxcbiAgICAgIHBhZGRpbmc6IGAke2dyaWRTaXplIC8gMn1weGAsXG4gICAgfX1cbiAgPlxuICAgIHtKU09OLnN0cmluZ2lmeShwcm9wcywgbnVsbCwgMil9XG4gIDwvcHJlPlxuKTtcblxuLyoqXG4gKiBHUk9VUFNcbiAqL1xuXG4vLyBHcm91cFxuY29uc3QgR3JvdXAgPSAoeyBjdXN0b21Db21wb25lbnRzLCBoYXNTZXBhcmF0b3IsIGhlYWRpbmcsIGl0ZW1zLCBpZCB9KSA9PlxuICBpdGVtcy5sZW5ndGggPyAoXG4gICAgPEdyb3VwQ29tcG9uZW50IGhlYWRpbmc9e2hlYWRpbmd9IGhhc1NlcGFyYXRvcj17aGFzU2VwYXJhdG9yfSBpZD17aWR9PlxuICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgPC9Hcm91cENvbXBvbmVudD5cbiAgKSA6IG51bGw7XG5cbmNvbnN0IFNvcnRhYmxlR3JvdXAgPSAoe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBoYXNTZXBhcmF0b3IsXG4gIGhlYWRpbmcsXG4gIGl0ZW1zLFxuICBpZCxcbn0pID0+XG4gIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA/IChcbiAgICA8TGF6eVNvcnRhYmxlR3JvdXBDb21wb25lbnRcbiAgICAgIGhlYWRpbmc9e2hlYWRpbmd9XG4gICAgICBoYXNTZXBhcmF0b3I9e2hhc1NlcGFyYXRvcn1cbiAgICAgIGlkPXtpZH1cbiAgICA+XG4gICAgICA8UmVuZGVyQmxvY2tlciBpdGVtcz17aXRlbXN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9PlxuICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyIGl0ZW1zPXtpdGVtc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICAgIDwvUmVuZGVyQmxvY2tlcj5cbiAgICA8L0xhenlTb3J0YWJsZUdyb3VwQ29tcG9uZW50PlxuICApIDogbnVsbDtcblxuLy8gU2VjdGlvblxuY29uc3QgU2VjdGlvbiA9ICh7XG4gIGFsd2F5c1Nob3dTY3JvbGxIaW50ID0gZmFsc2UsXG4gIGN1c3RvbUNvbXBvbmVudHMsXG4gIGlkLFxuICBpdGVtcyxcbiAgbmVzdGVkR3JvdXBLZXksXG4gIHBhcmVudElkLFxuICBzaG91bGRHcm93LFxufSkgPT5cbiAgaXRlbXMubGVuZ3RoID8gKFxuICAgIDxTZWN0aW9uQ29tcG9uZW50XG4gICAgICBhbHdheXNTaG93U2Nyb2xsSGludD17YWx3YXlzU2hvd1Njcm9sbEhpbnR9XG4gICAgICBpZD17aWR9XG4gICAgICBrZXk9e25lc3RlZEdyb3VwS2V5fVxuICAgICAgcGFyZW50SWQ9e3BhcmVudElkfVxuICAgICAgc2hvdWxkR3Jvdz17c2hvdWxkR3Jvd31cbiAgICA+XG4gICAgICB7KHsgY2xhc3NOYW1lIH0pID0+IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlclxuICAgICAgICAgICAgaXRlbXM9e2l0ZW1zfVxuICAgICAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9TZWN0aW9uQ29tcG9uZW50PlxuICApIDogbnVsbDtcblxuY29uc3QgSGVhZGVyU2VjdGlvbiA9ICh7IGN1c3RvbUNvbXBvbmVudHMsIGlkLCBpdGVtcywgbmVzdGVkR3JvdXBLZXkgfSkgPT5cbiAgaXRlbXMubGVuZ3RoID8gKFxuICAgIDxIZWFkZXJTZWN0aW9uQ29tcG9uZW50IGlkPXtpZH0ga2V5PXtuZXN0ZWRHcm91cEtleX0+XG4gICAgICB7KHsgY2xhc3NOYW1lIH0pID0+IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgPFR5cGVkSXRlbXNSZW5kZXJlclxuICAgICAgICAgICAgaXRlbXM9e2l0ZW1zfVxuICAgICAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9IZWFkZXJTZWN0aW9uQ29tcG9uZW50PlxuICApIDogbnVsbDtcblxuY29uc3QgTWVudVNlY3Rpb24gPSAoe1xuICBhbHdheXNTaG93U2Nyb2xsSGludCxcbiAgY3VzdG9tQ29tcG9uZW50cyxcbiAgaWQsXG4gIGl0ZW1zLFxuICBuZXN0ZWRHcm91cEtleSxcbiAgcGFyZW50SWQsXG59KSA9PiAoXG4gIDxNZW51U2VjdGlvbkNvbXBvbmVudFxuICAgIGFsd2F5c1Nob3dTY3JvbGxIaW50PXthbHdheXNTaG93U2Nyb2xsSGludH1cbiAgICBpZD17aWR9XG4gICAga2V5PXtuZXN0ZWRHcm91cEtleX1cbiAgICBwYXJlbnRJZD17cGFyZW50SWR9XG4gID5cbiAgICB7KHsgY2xhc3NOYW1lIH0pID0+IChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyIGl0ZW1zPXtpdGVtc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICAgIDwvZGl2PlxuICAgICl9XG4gIDwvTWVudVNlY3Rpb25Db21wb25lbnQ+XG4pO1xuXG5jb25zdCBTb3J0YWJsZUNvbnRleHQgPSAoe1xuICBjdXN0b21Db21wb25lbnRzLFxuICBpZCxcbiAgaXRlbXMsXG4gIG9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdVcGRhdGUsXG4gIG9uRHJhZ0VuZCxcbn0pID0+XG4gIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA/IChcbiAgICA8TGF6eVNvcnRhYmxlQ29udGV4dENvbXBvbmVudFxuICAgICAgaWQ9e2lkfVxuICAgICAgb25EcmFnU3RhcnQ9e29uRHJhZ1N0YXJ0fVxuICAgICAgb25EcmFnVXBkYXRlPXtvbkRyYWdVcGRhdGV9XG4gICAgICBvbkRyYWdFbmQ9e29uRHJhZ0VuZH1cbiAgICA+XG4gICAgICA8VHlwZWRJdGVtc1JlbmRlcmVyIGl0ZW1zPXtpdGVtc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICA8L0xhenlTb3J0YWJsZUNvbnRleHRDb21wb25lbnQ+XG4gICkgOiBudWxsO1xuXG5jb25zdCBpdGVtQ29tcG9uZW50cyA9IHtcbiAgQmFja0l0ZW0sXG4gIENvbnRhaW5lckhlYWRlcixcbiAgRGVidWcsXG4gIEdvVG9JdGVtLFxuICBHcm91cEhlYWRpbmcsXG4gIEl0ZW06IENvbm5lY3RlZEl0ZW0sXG4gIFNvcnRhYmxlSXRlbTogTGF6eVNvcnRhYmxlSXRlbSxcbiAgU2VjdGlvbkhlYWRpbmcsXG4gIFNlcGFyYXRvcixcbiAgU3dpdGNoZXI6IExhenlTd2l0Y2hlcixcbiAgV29yZG1hcmssXG59O1xuXG5jb25zdCByZW5kZXJJdGVtQ29tcG9uZW50ID0gKHByb3BzLCBrZXksIGluZGV4KSA9PiB7XG4gIGxldCBlbGVtZW50ID0gbnVsbDtcbiAgLy8gV2UgbmVlZCBhbiBleHBsaWNpdCBjb25kaXRpb25hbCBhZ2FpbnN0IGVhY2ggdHlwZSBmb3IgZmxvdyB0eXBlIHJlZmluZW1lbnQgdG8gd29ya1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ0JhY2tJdGVtJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPEJhY2tJdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdDb250YWluZXJIZWFkZXInKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8Q29udGFpbmVySGVhZGVyIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnRGVidWcnKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8RGVidWcga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdHb1RvSXRlbScpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxHb1RvSXRlbSBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gaW5kZXg9e2luZGV4fSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnSXRlbScpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxDb25uZWN0ZWRJdGVtIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSBpbmRleD17aW5kZXh9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTb3J0YWJsZUl0ZW0nKSB7XG4gICAgY29uc3QgeyB0eXBlLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8TGF6eVNvcnRhYmxlSXRlbSBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gaW5kZXg9e2luZGV4fSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU2VjdGlvbkhlYWRpbmcnKSB7XG4gICAgY29uc3QgeyB0eXBlLCBpZCwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gPFNlY3Rpb25IZWFkaW5nIGtleT17a2V5fSB7Li4uY29tcFByb3BzfSAvPjtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU2VwYXJhdG9yJykge1xuICAgIGNvbnN0IHsgdHlwZSwgaWQsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxTZXBhcmF0b3Iga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTd2l0Y2hlcicpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IDxMYXp5U3dpdGNoZXIga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdXb3JkbWFyaycpIHtcbiAgICBjb25zdCB7IHR5cGUsIGlkLCAuLi5jb21wUHJvcHMgfSA9IHByb3BzO1xuICAgIGVsZW1lbnQgPSA8V29yZG1hcmsga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IC8+O1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5jb25zdCBncm91cENvbXBvbmVudHMgPSB7XG4gIEdyb3VwLFxuICBIZWFkZXJTZWN0aW9uLFxuICBNZW51U2VjdGlvbixcbiAgU2VjdGlvbixcbiAgU29ydGFibGVDb250ZXh0LFxuICBTb3J0YWJsZUdyb3VwLFxufTtcblxuY29uc3QgcmVuZGVyR3JvdXBDb21wb25lbnQgPSAocHJvcHMsIGtleSwgY3VzdG9tQ29tcG9uZW50cykgPT4ge1xuICBsZXQgZWxlbWVudCA9IG51bGw7XG4gIC8vIFdlIG5lZWQgYW4gZXhwbGljaXQgY29uZGl0aW9uYWwgYWdhaW5zdCBlYWNoIHR5cGUgZm9yIGZsb3cgdHlwZSByZWZpbmVtZW50IHRvIHdvcmtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdHcm91cCcpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxHcm91cCBrZXk9e2tleX0gey4uLmNvbXBQcm9wc30gY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c30gLz5cbiAgICApO1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdIZWFkZXJTZWN0aW9uJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPEhlYWRlclNlY3Rpb25cbiAgICAgICAga2V5PXtrZXl9XG4gICAgICAgIHsuLi5jb21wUHJvcHN9XG4gICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAvPlxuICAgICk7XG4gIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ01lbnVTZWN0aW9uJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPE1lbnVTZWN0aW9uXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB7Li4uY29tcFByb3BzfVxuICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgLz5cbiAgICApO1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdTZWN0aW9uJykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPFNlY3Rpb24ga2V5PXtrZXl9IHsuLi5jb21wUHJvcHN9IGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9IC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU29ydGFibGVDb250ZXh0Jykge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcFByb3BzIH0gPSBwcm9wcztcbiAgICBlbGVtZW50ID0gKFxuICAgICAgPFNvcnRhYmxlQ29udGV4dFxuICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgey4uLmNvbXBQcm9wc31cbiAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgIC8+XG4gICAgKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnU29ydGFibGVHcm91cCcpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmNvbXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgZWxlbWVudCA9IChcbiAgICAgIDxTb3J0YWJsZUdyb3VwXG4gICAgICAgIGtleT17a2V5fVxuICAgICAgICB7Li4uY29tcFByb3BzfVxuICAgICAgICBjdXN0b21Db21wb25lbnRzPXtjdXN0b21Db21wb25lbnRzfVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vLyBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuZXhwb3J0IGNvbnN0IGNvbXBvbmVudHMgPSB7IC4uLml0ZW1Db21wb25lbnRzLCAuLi5ncm91cENvbXBvbmVudHMgfTtcblxuLyoqXG4gKiBSRU5ERVJFUlxuICovXG5jbGFzcyBUeXBlZEl0ZW1zUmVuZGVyZXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY3VzdG9tQ29tcG9uZW50c1dpdGhBbmFseXRpY3MgPSBuZXcgTWFwKCk7XG5cbiAgZ2V0Q3VzdG9tQ29tcG9uZW50ID0gY29tcG9uZW50ID0+IHtcbiAgICAvLyBjYWNoZSBjdXN0b20gY29tcG9uZW50cyB3cmFwcGVkIHdpdGggYW5hbHl0aWNzXG4gICAgLy8gdG8gcHJldmVudCByZS1tb3VudGluZyBvZiBjb21wb25lbnQgb24gcmUtcmVuZGVyXG4gICAgY29uc3QgeyBjdXN0b21Db21wb25lbnRzID0ge30gfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IGNhY2hlZENvbXBvbmVudCA9IHRoaXMuY3VzdG9tQ29tcG9uZW50c1dpdGhBbmFseXRpY3MuZ2V0KGNvbXBvbmVudCk7XG4gICAgaWYgKCFjYWNoZWRDb21wb25lbnQpIHtcbiAgICAgIGNhY2hlZENvbXBvbmVudCA9XG4gICAgICAgIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgPyBuYXZpZ2F0aW9uSXRlbUNsaWNrZWQoY3VzdG9tQ29tcG9uZW50c1tjb21wb25lbnRdLCBjb21wb25lbnQpXG4gICAgICAgICAgOiBuYXZpZ2F0aW9uSXRlbUNsaWNrZWQoXG4gICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgY29tcG9uZW50LmRpc3BsYXlOYW1lIHx8ICdpbmxpbmVDdXN0b21Db21wb25lbnQnLFxuICAgICAgICAgICAgKTtcbiAgICAgIHRoaXMuY3VzdG9tQ29tcG9uZW50c1dpdGhBbmFseXRpY3Muc2V0KGNvbXBvbmVudCwgY2FjaGVkQ29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZENvbXBvbmVudDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjdXN0b21Db21wb25lbnRzID0ge30sIGl0ZW1zIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gV2UgY2Fubm90IGRlc3RydWN0dXJlIHByb3BzLnR5cGUgb3RoZXJ3aXNlIGZsb3cgdHlwZSByZWZpbm1lbnQgZG9lcyBub3Qgd29ya1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81MjU5XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgocHJvcHMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBrZXkgPVxuICAgICAgICB0eXBlb2YgcHJvcHMubmVzdGVkR3JvdXBLZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgPyBwcm9wcy5uZXN0ZWRHcm91cEtleVxuICAgICAgICAgIDogcHJvcHMuaWQ7XG5cbiAgICAgIGlmIChwcm9wcy50eXBlID09PSAnSW5saW5lQ29tcG9uZW50Jykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIGNvbXBvbmVudCwgLi4uY29tcG9uZW50UHJvcHMgfSA9IHByb3BzO1xuICAgICAgICAvLyBJZiB0aGV5J3ZlIHByb3ZpZGVkIGEgY29tcG9uZW50IGFzIHRoZSB0eXBlXG4gICAgICAgIGNvbnN0IEN1c3RvbUNvbXBvbmVudCA9IHRoaXMuZ2V0Q3VzdG9tQ29tcG9uZW50KHByb3BzLmNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPEN1c3RvbUNvbXBvbmVudFxuICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICB7Li4uY29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAvLyBXZSBwYXNzIG91ciBpbi1idWlsdCBjb21wb25lbnRzIHRocm91Z2ggdG8gY3VzdG9tIGNvbXBvbmVudHMgc29cbiAgICAgICAgICAgIC8vIHRoZXkgY2FuIHdyYXAvcmVuZGVyIHRoZW0gaWYgdGhleSB3YW50IHRvLlxuICAgICAgICAgICAgY29tcG9uZW50cz17Y29tcG9uZW50c31cbiAgICAgICAgICAgIGN1c3RvbUNvbXBvbmVudHM9e2N1c3RvbUNvbXBvbmVudHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhncm91cENvbXBvbmVudHMpLmluY2x1ZGVzKHByb3BzLnR5cGUpKSB7XG4gICAgICAgIC8vIElmIHRoZXkndmUgcHJvdmlkZWQgYSB0eXBlIHdoaWNoIG1hdGNoZXMgb25lIG9mIG91ciBpbi1idWlsdCBncm91cFxuICAgICAgICAvLyBjb21wb25lbnRzXG4gICAgICAgIHJldHVybiByZW5kZXJHcm91cENvbXBvbmVudChwcm9wcywga2V5LCBjdXN0b21Db21wb25lbnRzKTtcbiAgICAgICAgLy8gSWYgdGhleSd2ZSBwcm92aWRlZCBhIHR5cGUgd2hpY2ggbWF0Y2hlcyBvbmUgb2Ygb3VyIGluLWJ1aWx0IGl0ZW1cbiAgICAgICAgLy8gY29tcG9uZW50cy5cbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhpdGVtQ29tcG9uZW50cykuaW5jbHVkZXMocHJvcHMudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckl0ZW1Db21wb25lbnQocHJvcHMsIGtleSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGN1c3RvbUNvbXBvbmVudHMpLmluY2x1ZGVzKHByb3BzLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgLi4uY29tcG9uZW50UHJvcHMgfSA9IHByb3BzO1xuICAgICAgICAvLyBJZiB0aGV5J3ZlIHByb3ZpZGVkIGEgdHlwZSB3aGljaCBtYXRjaGVzIG9uZSBvZiB0aGVpciBkZWZpbmVkIGN1c3RvbVxuICAgICAgICAvLyBjb21wb25lbnRzLlxuICAgICAgICBjb25zdCBDdXN0b21Db21wb25lbnQgPSB0aGlzLmdldEN1c3RvbUNvbXBvbmVudCh0eXBlKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50XG4gICAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICAgIHsuLi5jb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIC8vIFdlIHBhc3Mgb3VyIGluLWJ1aWx0IGNvbXBvbmVudHMgdGhyb3VnaCB0byBjdXN0b20gY29tcG9uZW50cyBzb1xuICAgICAgICAgICAgLy8gdGhleSBjYW4gd3JhcC9yZW5kZXIgdGhlbSBpZiB0aGV5IHdhbnQgdG8uXG4gICAgICAgICAgICBjb21wb25lbnRzPXtjb21wb25lbnRzfVxuICAgICAgICAgICAgY3VzdG9tQ29tcG9uZW50cz17Y3VzdG9tQ29tcG9uZW50c31cbiAgICAgICAgICAvPlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gPERlYnVnIGtleT17a2V5fSB0eXBlPXtwcm9wcy50eXBlfSB7Li4ucHJvcHN9IC8+O1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFR5cGVkSXRlbXNSZW5kZXJlcjtcbiJdfQ== */")
  }, JSON.stringify(props, null, 2));
};
/**
 * GROUPS
 */
// Group


var Group = function Group(_ref3) {
  var customComponents = _ref3.customComponents,
      hasSeparator = _ref3.hasSeparator,
      heading = _ref3.heading,
      items = _ref3.items,
      id = _ref3.id;
  return items.length ? ___EmotionJSX(GroupComponent, {
    heading: heading,
    hasSeparator: hasSeparator,
    id: id
  }, ___EmotionJSX(TypedItemsRenderer, {
    items: items,
    customComponents: customComponents
  })) : null;
};

var SortableGroup = function SortableGroup(_ref4) {
  var customComponents = _ref4.customComponents,
      hasSeparator = _ref4.hasSeparator,
      heading = _ref4.heading,
      items = _ref4.items,
      id = _ref4.id;
  return items && items.length ? ___EmotionJSX(LazySortableGroupComponent, {
    heading: heading,
    hasSeparator: hasSeparator,
    id: id
  }, ___EmotionJSX(RenderBlocker, {
    items: items,
    customComponents: customComponents
  }, ___EmotionJSX(TypedItemsRenderer, {
    items: items,
    customComponents: customComponents
  }))) : null;
}; // Section


var Section = function Section(_ref5) {
  var _ref5$alwaysShowScrol = _ref5.alwaysShowScrollHint,
      alwaysShowScrollHint = _ref5$alwaysShowScrol === void 0 ? false : _ref5$alwaysShowScrol,
      customComponents = _ref5.customComponents,
      id = _ref5.id,
      items = _ref5.items,
      nestedGroupKey = _ref5.nestedGroupKey,
      parentId = _ref5.parentId,
      shouldGrow = _ref5.shouldGrow;
  return items.length ? ___EmotionJSX(SectionComponent, {
    alwaysShowScrollHint: alwaysShowScrollHint,
    id: id,
    key: nestedGroupKey,
    parentId: parentId,
    shouldGrow: shouldGrow
  }, function (_ref6) {
    var className = _ref6.className;
    return ___EmotionJSX("div", {
      className: className
    }, ___EmotionJSX(TypedItemsRenderer, {
      items: items,
      customComponents: customComponents
    }));
  }) : null;
};

var HeaderSection = function HeaderSection(_ref7) {
  var customComponents = _ref7.customComponents,
      id = _ref7.id,
      items = _ref7.items,
      nestedGroupKey = _ref7.nestedGroupKey;
  return items.length ? ___EmotionJSX(HeaderSectionComponent, {
    id: id,
    key: nestedGroupKey
  }, function (_ref8) {
    var className = _ref8.className;
    return ___EmotionJSX("div", {
      className: className
    }, ___EmotionJSX(TypedItemsRenderer, {
      items: items,
      customComponents: customComponents
    }));
  }) : null;
};

var MenuSection = function MenuSection(_ref9) {
  var alwaysShowScrollHint = _ref9.alwaysShowScrollHint,
      customComponents = _ref9.customComponents,
      id = _ref9.id,
      items = _ref9.items,
      nestedGroupKey = _ref9.nestedGroupKey,
      parentId = _ref9.parentId;
  return ___EmotionJSX(MenuSectionComponent, {
    alwaysShowScrollHint: alwaysShowScrollHint,
    id: id,
    key: nestedGroupKey,
    parentId: parentId
  }, function (_ref10) {
    var className = _ref10.className;
    return ___EmotionJSX("div", {
      className: className
    }, ___EmotionJSX(TypedItemsRenderer, {
      items: items,
      customComponents: customComponents
    }));
  });
};

var SortableContext = function SortableContext(_ref11) {
  var customComponents = _ref11.customComponents,
      id = _ref11.id,
      items = _ref11.items,
      onDragStart = _ref11.onDragStart,
      onDragUpdate = _ref11.onDragUpdate,
      onDragEnd = _ref11.onDragEnd;
  return items && items.length ? ___EmotionJSX(LazySortableContextComponent, {
    id: id,
    onDragStart: onDragStart,
    onDragUpdate: onDragUpdate,
    onDragEnd: onDragEnd
  }, ___EmotionJSX(TypedItemsRenderer, {
    items: items,
    customComponents: customComponents
  })) : null;
};

var itemComponents = {
  BackItem: BackItem,
  ContainerHeader: ContainerHeader,
  Debug: Debug,
  GoToItem: GoToItem,
  GroupHeading: GroupHeading,
  Item: ConnectedItem,
  SortableItem: LazySortableItem,
  SectionHeading: SectionHeading,
  Separator: Separator,
  Switcher: LazySwitcher,
  Wordmark: Wordmark
};

var renderItemComponent = function renderItemComponent(props, key, index) {
  var element = null; // We need an explicit conditional against each type for flow type refinement to work

  if (props.type === 'BackItem') {
    var type = props.type,
        compProps = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(BackItem, _extends({
      key: key
    }, compProps, {
      index: index
    }));
  } else if (props.type === 'ContainerHeader') {
    var _type = props.type,
        _compProps = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(ContainerHeader, _extends({
      key: key
    }, _compProps));
  } else if (props.type === 'Debug') {
    var _type2 = props.type,
        _compProps2 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(Debug, _extends({
      key: key
    }, _compProps2));
  } else if (props.type === 'GoToItem') {
    var _type3 = props.type,
        _compProps3 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(GoToItem, _extends({
      key: key
    }, _compProps3, {
      index: index
    }));
  } else if (props.type === 'Item') {
    var _type4 = props.type,
        _compProps4 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(ConnectedItem, _extends({
      key: key
    }, _compProps4, {
      index: index
    }));
  } else if (props.type === 'SortableItem') {
    var _type5 = props.type,
        _compProps5 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(LazySortableItem, _extends({
      key: key
    }, _compProps5, {
      index: index
    }));
  } else if (props.type === 'SectionHeading') {
    var _type6 = props.type,
        id = props.id,
        _compProps6 = _objectWithoutProperties(props, ["type", "id"]);

    element = ___EmotionJSX(SectionHeading, _extends({
      key: key
    }, _compProps6));
  } else if (props.type === 'Separator') {
    var _type7 = props.type,
        _id = props.id,
        _compProps7 = _objectWithoutProperties(props, ["type", "id"]);

    element = ___EmotionJSX(Separator, _extends({
      key: key
    }, _compProps7));
  } else if (props.type === 'Switcher') {
    var _type8 = props.type,
        _compProps8 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(LazySwitcher, _extends({
      key: key
    }, _compProps8));
  } else if (props.type === 'Wordmark') {
    var _type9 = props.type,
        _id2 = props.id,
        _compProps9 = _objectWithoutProperties(props, ["type", "id"]);

    element = ___EmotionJSX(Wordmark, _extends({
      key: key
    }, _compProps9));
  }

  return element;
};

var groupComponents = {
  Group: Group,
  HeaderSection: HeaderSection,
  MenuSection: MenuSection,
  Section: Section,
  SortableContext: SortableContext,
  SortableGroup: SortableGroup
};

var renderGroupComponent = function renderGroupComponent(props, key, customComponents) {
  var element = null; // We need an explicit conditional against each type for flow type refinement to work

  if (props.type === 'Group') {
    var type = props.type,
        compProps = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(Group, _extends({
      key: key
    }, compProps, {
      customComponents: customComponents
    }));
  } else if (props.type === 'HeaderSection') {
    var _type10 = props.type,
        _compProps10 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(HeaderSection, _extends({
      key: key
    }, _compProps10, {
      customComponents: customComponents
    }));
  } else if (props.type === 'MenuSection') {
    var _type11 = props.type,
        _compProps11 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(MenuSection, _extends({
      key: key
    }, _compProps11, {
      customComponents: customComponents
    }));
  } else if (props.type === 'Section') {
    var _type12 = props.type,
        _compProps12 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(Section, _extends({
      key: key
    }, _compProps12, {
      customComponents: customComponents
    }));
  } else if (props.type === 'SortableContext') {
    var _type13 = props.type,
        _compProps13 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(SortableContext, _extends({
      key: key
    }, _compProps13, {
      customComponents: customComponents
    }));
  } else if (props.type === 'SortableGroup') {
    var _type14 = props.type,
        _compProps14 = _objectWithoutProperties(props, ["type"]);

    element = ___EmotionJSX(SortableGroup, _extends({
      key: key
    }, _compProps14, {
      customComponents: customComponents
    }));
  }

  return element;
}; // Exported for testing purposes only.


export var components = _objectSpread({}, itemComponents, groupComponents);
/**
 * RENDERER
 */

var TypedItemsRenderer =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(TypedItemsRenderer, _PureComponent);

  function TypedItemsRenderer() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, TypedItemsRenderer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TypedItemsRenderer)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "customComponentsWithAnalytics", new Map());

    _defineProperty(_assertThisInitialized(_this), "getCustomComponent", function (component) {
      // cache custom components wrapped with analytics
      // to prevent re-mounting of component on re-render
      var _this$props$customCom = _this.props.customComponents,
          customComponents = _this$props$customCom === void 0 ? {} : _this$props$customCom;

      var cachedComponent = _this.customComponentsWithAnalytics.get(component);

      if (!cachedComponent) {
        cachedComponent = typeof component === 'string' ? navigationItemClicked(customComponents[component], component) : navigationItemClicked(component, component.displayName || 'inlineCustomComponent');

        _this.customComponentsWithAnalytics.set(component, cachedComponent);
      }

      return cachedComponent;
    });

    return _this;
  }

  _createClass(TypedItemsRenderer, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          _this$props$customCom2 = _this$props.customComponents,
          customComponents = _this$props$customCom2 === void 0 ? {} : _this$props$customCom2,
          items = _this$props.items; // We cannot destructure props.type otherwise flow type refinment does not work
      // https://github.com/facebook/flow/issues/5259

      return items.map(function (props, index) {
        var key = typeof props.nestedGroupKey === 'string' ? props.nestedGroupKey : props.id;

        if (props.type === 'InlineComponent') {
          var type = props.type,
              component = props.component,
              componentProps = _objectWithoutProperties(props, ["type", "component"]); // If they've provided a component as the type


          var CustomComponent = _this2.getCustomComponent(props.component);

          return ___EmotionJSX(CustomComponent, _extends({
            key: key
          }, componentProps, {
            index: index // We pass our in-built components through to custom components so
            // they can wrap/render them if they want to.
            ,
            components: components,
            customComponents: customComponents
          }));
        }

        if (Object.keys(groupComponents).includes(props.type)) {
          // If they've provided a type which matches one of our in-built group
          // components
          return renderGroupComponent(props, key, customComponents); // If they've provided a type which matches one of our in-built item
          // components.
        }

        if (Object.keys(itemComponents).includes(props.type)) {
          return renderItemComponent(props, key, index);
        }

        if (Object.keys(customComponents).includes(props.type)) {
          var _type15 = props.type,
              _componentProps = _objectWithoutProperties(props, ["type"]); // If they've provided a type which matches one of their defined custom
          // components.


          var _CustomComponent = _this2.getCustomComponent(_type15);

          return ___EmotionJSX(_CustomComponent, _extends({
            key: key
          }, _componentProps, {
            index: index // We pass our in-built components through to custom components so
            // they can wrap/render them if they want to.
            ,
            components: components,
            customComponents: customComponents
          }));
        }

        return ___EmotionJSX(Debug, _extends({
          key: key,
          type: props.type
        }, props));
      });
    }
  }]);

  return TypedItemsRenderer;
}(PureComponent);

export default TypedItemsRenderer;